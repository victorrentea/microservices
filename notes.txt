All slides: https://victorrentea.ro/slides/
These notes.txt: 
https://drive.google.com/open?id=1_LREM2Q0HyP78rGnP531ovAesdmCiKd4&usp=drive_fs
(you'll get a link to them soon)

Join my community: 
https://www.meetup.com/european-software-crafters/





What is a microservice? And why would I need them?
=  it's an application (deployable) with a few responsibilities (ideally 1)
=== Split DOAR daca ===
+ isolated from eachother: fault-tolerant to others becoming unavailable
+ deployable independently: safer to release, eg java upg to 25
+ scalable independently:
    scale out(horizontal)=add more machines
    > elastic scaling out/in in face of variable load to and preserve SLAs(errors%,latency) in face of higher load later cost-optimize
    scale up (vertical)= add resources(CPU/mem) to 1 machine
+ technology independent: C#, Java, Py/ml, Scala..
+ better separation between teams (separate Git repo)

Â± Monitoring   
    + when one service goes wild, it's quick to see who to blame
    - a lot of tech stacks: NewRelic for metrics, traces, log aggregation


ðŸš© Have we split the microsevices too small? Consider merging them back.
- PRs touching 2+ for > 50% of features





become possible: "Trunk-based development"=the death of Feature-Branches; devs add code to 'master' and app gets deployed continuously. Code review is replaced with Pair Programming. you keep adding to a shared 'master' code every day, guarded by feature flags set to false. Â±TDD


- how do they integrate with the others?  
   > SYNC(REST)/ASYNC(pubsub,rabbit,kafka,MQ,solace)

Sharing a DB with other apps?
+consistency
+no data replication
+troubleshooting
+cheaper (at start)
+faster(JDBC:binary
   +JOIN them' all)

-alter table is hard
-race bugs
-deadlock SELECT FOR  UPDATE: A,B   B,A
-SPOFailure
-Bottleneck
-PRIVACY (think:GDPR)
-who owns this table?
 =>separate schema/app
 =>GO_LOAN, JA_LOAN






Agenda:
Day1 - Micro Pros/Cons, REST API design
Day2 - Resilience, Observability
Day3 - Message-based comm




=== NFRs = Non-Functional Requirements, aka "-ility" ===
=== Architecture Qualities ===
- availability of services in the core domain (business-critical): add-to-cart, checkout, catalog, authnÂ± 
    - 99% => yearly downtime = 3.65 days
    - 99.999% => downtime = 5.26 minutes/year
- fault-tolerance
- recoverability: MTTR=RTO after a failure
- throughput: no of requests/messages/line processed /time
- scalability: when load increases (~no of users)
    - latency + %error=~constant
    - costs should increase lineary
- latency: <1s (naive); correct 100ms 95%th for 50rps
- agility (aka lead time): release to prod daily; in the meantime, in automotive, release cycles of 2y.
- privacy: eg data retention GDPR, right to be forgotten
    > here in DB we hold on your data for 99 years. we HAVE to REMEMBER EVERYTHING; good luck migrating your DB.
- regulatory/legal: "legal hold" @Test to prove the data in the new GCP-based system === one in the old ORA-based system to get the business signoff.
- accesibility UX: color blind etc, support for screen reader (eg: <button alt="human readable for blind">)
- extensibility: ability to add more features with low impact 
- traceability: CREDIT.APPROVED_BY_USERNAME, .LAST_MODIFIED_BY='my cousin'
- observability = {metrics,logs,alerts,tracing}





you plan to breaking-change your REST API. How do you know who is using it?
- request header: Client-Id: <caller-app>
(requires client collab)
- Auth headers: Authorization: Basic
- Auth headers: Authorization: Bearer <jwt>
- Auth headers: X-ApiKey: 08qyr29y2379r23yr798236
- 2TLS: client-certif 
- Cookies for bro' clients
- TraceId/traceparent



https://github.com/victorrentea/clean-architecture.git

Cum aflii deps tranzitive aduse de spring boot parent ver X
https://repo1.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/3.3.5/spring-boot-dependencies-3.3.5.pom

Notes.txt are here:
https://github.com/victorrentea/microservices/blob/db25/notes.txt

=== ðŸ† How do we find correct boundaries of Microservices? ðŸ† ===
âœ‚ï¸ NFRs: availability, scalability
âœ‚ï¸ Tech freedom: eg py for ML
âœ‚ï¸ Reusable across technologies
âœ‚ï¸ Separate groups of bu$iness people (stakeholders): invoicing, inventory,
   Conway's Law: orgs will produce systems that will match structure of the org
âœ‚ï¸ Service-proxy: vs BPM, SAP, COBOL, ANAF
âœ‚ï¸ Api Gateway
ðŸ’– Frequent cross-changes 
ðŸ’– Clients typically need data from everywhere. also consider CQRS
ðŸ’– Sync-fetch bulks of data of another service
ðŸ’– 

"Reporting"=visualising trends (graphs) for analytics, recomm, steer the business. How should *THEY* get my data?
- SELECT from prod DB = COUPLING to my deareast of all-DB
    - E-T-L every Sun night -- Too late
    - only my VIEWS
    Whenver we alter a table, #care for BI. make them a view until they adjust their queries.
- ask you to push data to them via files over sftp; what schema?; CSV is back | | | | 
- ðŸ’–Real-time publish them a Kafka event. #welcome to the future


imagine eMag, subdomains:
- marketing / ads
- catalog (browsing, search, comparing)
- sales = b2b
- inventory = WMS
- invoicing
- customers = CRM 
- fulfillment not "order"
- reviews & recommendations
- shipping
- finance
- marketplace
- after sales (warranty, refunds, service)







Legend: âœ‚ï¸reason to split, ðŸ’–reason to merge(keep together)



TODO PATCH
- We had a multi-step wizzard that filled 200+ fields of a Bond. Step1>2>3>Finish

PATCH bond/{id} {+50 attributes} after step1
PUT bond/{id}/step1 {+50 attributes} 
metamodel of our data: 
[{fieldName:"title", type:"string", length:20}...]


REST API Design advices:
- preserve bacwards compatibility with a @Test
- integration-test to prove their API didn't change
- GET /item/{id} -> consider a batch query API
- @GetMapping DomainModel // NEVER
- have ..Response ..Request objects instead of Dto
- item/id/validate reads better than PUT /item/id/status
- PATCH avoid
- Errors







clonati: https://github.com/victorrentea/resilience
mvn install -> what errors? 
2nd hour we'll work on itðŸ¤ž

worked 
- without ZScaler + IntraWL
- and with ZScaler + GuestWL: INSpireTRU$T


--- RESILIENCE
- Async HTTP: 202 ACcepted+URL to poll 
- Inbox Table = Store, then process
- Failure Unit design
- Failover cache
- Queueing: delaying some work to keep in comfort zone

- Circuit Breaker
- Istio
- Api Gateway

--- OPS
- Log aggregation (Splunk=log aggregator); json log format in prod; text on local; obfuscate GDPR before logging
    - OTEL "baggage" that propagates across systems, and visible in Splunk columns.
    one projects logs 250GB/day: 1GB zip/day
        prod.log.level=INFO
        What should we log on INFO?
    traceId to allow you to correlate logs in CallerService->CalledService
    micrometer-open telemetry: Free stack: Micrometer in java -> Prometheus -> Grafana

New Relic: Performance 
- Traces allow us to overview the entire chain of a flow (all the systems/DBs involved), and detect where most time is lost -> New Relic SEE @George knows best.
- Metrics: #musthave set Prod alerts



- Helm Charts
- Health probes
- Deployment strategies